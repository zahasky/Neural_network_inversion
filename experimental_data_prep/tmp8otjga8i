# -*- coding: utf-8 -*-
"""
Created on Tue Mar 23 17:44:19 2021

@author: zahas
"""
import os
import numpy as np
import matplotlib.pyplot as plt

def quantile_function(btc_1d, timearray, quantile, t_increment):
    # first moment calculation
    m0 = np.trapz(btc_1d, timearray)
    m1 = np.trapz(btc_1d*timearray, timearray)
    M1 = m1/m0
        
    for i in range(2, ntime):
        M0i = np.trapz(btc_1d[:i], timearray[:i])
    
        if M0i/m0 > quantile:
            M0im = np.trapz(btc_1d[:i-1], timearray[:i-1])
            # linear interpolation
            m = (btc_1d[i-1] - btc_1d[i-2])/(timearray[i-1] - timearray[i-2])
            b = btc_1d[i-2] - m*timearray[i-2]
        
            for xt in np.arange(timearray[i-2], timearray[i-1]+t_increment, t_increment):
                M0int = M0im + np.trapz([btc_1d[i-2], m*xt+b], [timearray[i-2], xt])
            
                if M0int/m0 > quantile:
                    tau = xt
                    print(tau)
                    break
            
            break
        # output the line that is being used for linear interpolation of quantile
        x = np.arange(timearray[i-2], timearray[i-1], t_increment)
        
    return tau, M1, x, m, b




# # ketton
# data_filename = 'Ketton_4ml_1_2_3mm_cropped_nan'
# phi = 48.7/((3.1415*2.54**2)*10)
# km2 = 1920*9.869233E-13/1000

# Berea
data_filename = 'Berea_C1_1ml_2_3mm_cropped_nan'

timestep = 4
# =============================================================================
# LOAD SELECTED EXAMPLE DATA 
# =============================================================================
# Set path to experimental data
data_dir = os.path.join('.', 'pet_data')
# data_dir = os.path.join('.')

# Import data
all_data = np.loadtxt(data_dir + '\\' + data_filename + '.csv', delimiter=',')

# PET_size(1); PET_size(2); PET_size(3); PET_size(4); timestep_length; q; inj_pv; vox_size(:)])
dz = all_data[-1] # voxel size in z direction (parallel to axis of core)
dy = all_data[-2] # voxel size in y direction
dx = all_data[-3] # voxel size in x direction
tracer_volume = all_data[-4] # tracer injected (ml)
q = all_data[-5] # flow rate (ml/min)
tstep = all_data[-6] # timstep length (sec)
ntime = int(all_data[-7])
nslice = int(all_data[-8])
nrow = int(all_data[-10])
ncol = int(all_data[-9])
# calculate tracer injection duration in seconds
tracer_inj_duration = tracer_volume/q*60 

# crop off dataset information
pet_data = all_data[0:-10]
# reshape from imported column vector to 4D matrix
pet_data = pet_data.reshape(nrow, ncol, nslice, ntime)
# crop edges
pet_data = pet_data[1:-1, 1:-1, :, :]

C1d = np.nansum(np.nansum(pet_data, 0), 0)
timearray = np.arange(tstep/2, tstep*ntime, tstep)
# # BTC at a given location
# btc_1d = C1d[-1,:]

btc_1d = pet_data[0,7, 3,:]
    
    
quantile = 0.5
t_increment = 1

tau, M1, x, m, b = quantile_function(btc_1d, timearray, quantile, t_increment)
    
plt.figure(figsize=(8, 4), dpi=200)
plt.plot(timearray, btc_1d, '-ok')
plt.plot(x, m*x+b, '--r')

plt.plot([tau, tau], [0, np.max(btc_1d)], label = '0.5 quantile')
plt.plot([M1, M1], [0, np.max(btc_1d)], 'g', label = 'normalized first moment')
plt.legend()
plt.xlabel('Time [min]')

# Play around with plotting volumes

from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib

def set_axes_equal(ax):
    '''Make axes of 3D plot have equal scale so that spheres appear as spheres,
    cubes as cubes, etc..  This is one possible solution to Matplotlib's
    ax.set_aspect('equal') and ax.axis('equal') not working for 3D.

    Input
      ax: a matplotlib axis, e.g., as output from plt.gca().
    '''

    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    x_range = abs(x_limits[1] - x_limits[0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits[1] - y_limits[0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits[1] - z_limits[0])
    z_middle = np.mean(z_limits)

    # The plot bounding box is a sphere in the sense of the infinity
    # norm, hence I call half the max range the plot radius.
    plot_radius = 0.5*max([x_range, y_range, z_range])

    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])
    
def half_core(data):
    r,c,s = np.shape(data)
    data = data[:,:-round(c/2),:]
    ncol = round(c/2)
    return data, ncol


# Import arrival time data
arrival_data_filename = '\\Berea_C1_1ml_2_3mm_at_norm' 
data_dir_arrival = os.path.join('.', '\pet_arrival_time_data')
# Import data
arrival_data = np.loadtxt(data_dir_arrival + '\\' + arrival_data_filename + '.csv', delimiter=',')

arrival_data = arrival_data[0:-1]
nslice = 40
nrow = 20
ncol = 20
arrival_data = arrival_data.reshape(nrow, ncol, nslice)
# plot_2d(arrival_data[:,11,:], dz, dy, 'arrival time', cmap='bwr')


# crop core
arrival_data, ncol = half_core(arrival_data)
# swap axes
arrival_data = np.swapaxes(arrival_data,0,2)

# generate grid    
X, Y, Z = np.meshgrid(np.linspace(dy/2, (ncol-2)*dy+dy/2, num=(ncol+1)), \
                      np.linspace(dz/2, (nslice-2)*dz+dz/2, num=(nslice+1)), \
                      np.linspace(dx/2, (nrow-2)*dx+dx/2, num=(nrow+1)))


angle = -25
fig = plt.figure(figsize=(12, 9), dpi=300)
ax = fig.gca(projection='3d')
ax.view_init(25, angle)
# ax.set_aspect('equal') 

    
norm = matplotlib.colors.Normalize(vmin=arrival_data.min().min(), vmax=arrival_data.max().max())
    
# ax.voxels(filled, facecolors=facecolors, edgecolors='gray', shade=False)
ax.voxels(X, Y, Z, arrival_data, facecolors=plt.cm.bwr(norm(arrival_data)), \
          edgecolors='grey', linewidth=0.2, shade=False, alpha=0.7)

m = cm.ScalarMappable(cmap=plt.cm.bwr, norm=norm)
m.set_array([])
# format colorbar
divider = make_axes_locatable(ax)
# cax = divider.append_axes("right", pad=0.05)
# cax = divider.append_axes("right", size="5%", pad=0.05)
plt.colorbar(m, shrink=0.5)
set_axes_equal(ax)
# ax.set_xlim3d([0, 4])
ax.set_axis_off()

# invert z axis for matrix coordinates
ax.invert_zaxis()
# Set background color to white (grey is default)
ax.w_xaxis.set_pane_color((1.0, 1.0, 1.0, 1.0))
ax.w_yaxis.set_pane_color((1.0, 1.0, 1.0, 1.0))
ax.w_zaxis.set_pane_color((1.0, 1.0, 1.0, 1.0))
# ax.grid(False)

plt.show()
    
