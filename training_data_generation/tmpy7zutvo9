# -*- coding: utf-8 -*-
"""
flopy_arrival_time_3d_diff_generation.py
Created on Fri Jun  5 08:23:38 2020

@author: Christopher Zahasky

This script is used to generate 3D arrival time maps using synthetically 
generated 3D permeability fields. This script calls functions from the python
script titled 'flopy_bt_3d_functions.py'
"""

# Only packages called in this script need to be imported
import sys
import os
import shutil
import numpy as np
import matplotlib.pyplot as plt
import time

# Packages for random field generation
import gstools as gs
from skopt.sampler import Lhs

# Import custom functions to run flopy stuff, the calls should be structured as:
# from file import function
from flopy_arrival_time_3d_functions import mt3d_pulse_injection_sim, flopy_arrival_map_function, plot_2d

## LAPTOP PATHS
# names of executable with path IF NOT IN CURRENT DIRECTORY
# exe_name_mf = 'C:\\Users\\zahas\\Dropbox\\Research\\Simulation\\modflow\\executables\\mf2005'
# exe_name_mt = 'C:\\Users\\zahas\\Dropbox\\Research\\Simulation\\modflow\\executables\\mt3dms'

# DELL 419 PATHS
# names of executable with path IF NOT IN CURRENT DIRECTORY
exe_name_mf = 'D:\\Dropbox\\Research\\Simulation\\modflow\\executables\\mf2005'
exe_name_mt = 'D:\\Dropbox\\Research\\Simulation\\modflow\\executables\\mt3dms'

# directory to save data
# directory_name = 'examples'
# workdir = os.path.join('.', '3D_fields', directory_name)
directory_name = 'arrival_time_maps'
workdir = os.path.join('D:\\Training_data_generation_3D\\tdata_python26k', directory_name)

# Set path to perm maps
# perm_field_dir = os.path.join('.')
# perm_field_dir = os.path.join('.', '3D_fields', directory_name)
perm_field_dir = os.path.join('D:\\Training_data_generation_3D\\tdata_python26k\\syn_core_perm_maps')

# Import core shape mask
core_mask = np.loadtxt('core_mask.csv', delimiter=',')

# =============================================================================
# PARAMETER SPACE DEFINITION
# =============================================================================
generate_fields = True

# number of training datasets desired
ntraining_data = 5
# number of extra datasets to generate in case of sim or at calc failure
extra_sets = 100

if generate_fields == True:
    lhs = Lhs(lhs_type="classic", criterion=None)
    
    # log_var, log_mD(10 mD to 20 D), x len, y len, z len, rotation x, rotation y, rotation z
    Ps = lhs.generate([(-4., -0.5), (1.0, 4.3), (1.0, 50.), (1.0, 50.0), (1.0, 50.0), \
                      (0.0, 1.57), (0.0, 1.57), (0.0, 1.57), (1,3)], ntraining_data + extra_sets)
    
    # example of how to efficiently save data to text file    
    np.savetxt('parameter_space_26k.csv', Ps , delimiter=',', fmt='%.3e')
else:
    Ps = np.loadtxt('parameter_space_26k.csv', delimiter=',')
    
# =============================================================================
# VARIABLES THAT DON'T CHANGE
# =============================================================================
# grid_size = [grid size in direction of Lx (layer thickness), 
    # Ly (left to right axis when looking down the core), Lz (long axis of core)]
grid_size = [0.23291, 0.23291, 0.25] # selected units [cm]
# grid dimensions
nlay = 20 # number of layers / grid cells
nrow = 20 # number of columns 
ncol = 40 # number of slices (parallel to axis of core)

# Output control for MT3dms
# nprs (int):  the frequency of the output. If nprs > 0 results will be saved at 
# the times as specified in timprs (evenly allocated between 0 and sim run length); 
# if nprs = 0, results will not be saved except at the end of simulation; if NPRS < 0, simulation results will be 
# saved whenever the number of transport steps is an even multiple of nprs. (default is 0).
nprs = 150 
# period length in selected units (minutes)
# the first period is fluid pressure equilibration, the second period is tracer
# injection, the third period is tracer displacement
perlen_mt = [2., 1., 90]
# Numerical method flag
mixelm = -1

# Call function and time it
start_td = time.time() # start a timer

# value of back up realizations to draw from
replacement_counter = ntraining_data + 1

td = 2
while td < ntraining_data:
    
    print('TRAINING DATASET: ' + str(td))
       
    # ========================================================================
    # PERMEABILITY FIELD GENERATION
    # ========================================================================
    p = Ps[td]
    if generate_fields == True:
        model = gs.Exponential(dim=3, var=10**p[0], len_scale=[p[2], p[3], p[4]], angles=[p[5], p[6], p[7]])
        srf = gs.SRF(model, seed=20170519)
        # permeability field in millidarcy
        field = 10**(srf.structured([np.arange(nlay), np.arange(nrow), np.arange(ncol)]) + p[1])
        # convert from mD to km^2
        field_km2 = field*(9.869233E-13/1000)
        # set permeability values outside of core to zero with core mask
        for col in range(ncol):
            field_km2[:,:,col] = np.multiply(field_km2[:,:,col], core_mask)
        
        # Save data in small format
        save_data = np.append(field_km2.flatten('C'), [nlay, nrow, ncol])
        np.savetxt(perm_field_dir + '\\core_k_3d_m2_' + str(td)+'.csv', save_data , delimiter=',', fmt='%.3e')
    else:
        # Import permeability map
        field_km2 = np.loadtxt(perm_field_dir + '\\core_k_3d_m2_' + str(td) +'.csv', delimiter=',')
        field_km2 = field_km2.reshape(nlay, nrow, ncol)
    
    # number of dummy slices at inlet boundary
    ndummy_in = int(p[8])  
    # Convert permeabiltiy (in m^2) to hydraulic conductivity in cm/min
    raw_hk = field_km2*(1000*9.81*100*60/8.9E-4)
    
    # Describe grid for results    
    Lx = (ncol) * grid_size[2]   # length of model in selected units 
    Ly = (nrow) * grid_size[1]   # length of model in selected units 
    # number of dummy slices
    ndummy_in = p[8]
    # Model workspace and new sub-directory
    model_dirname = ('td'+ str(td))
    model_ws = os.path.join(workdir, model_dirname)
    
    mf, mt, conc, timearray, km2_mean = mt3d_pulse_injection_sim(model_dirname, 
                model_ws, raw_hk, grid_size, ndummy_in,  perlen_mt, nprs, 
                mixelm, exe_name_mf, exe_name_mt)
    # print('Core average perm: '+ str(km2_mean) + ' m^2')
    
    # Option to plot and calculate geometric mean to double check that core average perm in close
    # raw_km2_array = field_km2.flatten()
    # index = np.argwhere(raw_km2_array > 0) 
    # geo_mean = np.exp(np.sum(np.log(raw_km2_array[index]))/index.size)
    # print('Geometric mean perm: ' + str(geo_mean) + ' m^2')
    
    # calculate quantile arrival time map from MT3D simulation results
    at_array, at_array_norm, at_diff_norm = flopy_arrival_map_function(conc, np.array(timearray), grid_size, 0.5)
    
    # In some cases the models may fail to run or there are issues with calculating arrival times
    # When this happens the realization is replaced with a random realization 
    # from a second sampling. This occurs less than 50 times in the entire 
    # 20,000 data initially generated
    if isinstance(at_diff_norm, int):
        # replace parameters
        Ps[td] = Ps[replacement_counter]
        # resave parameter space information  
        np.savetxt('parameter_space_26k.csv', Ps , delimiter=',', fmt='%.3e')
        print('Training dataset: ' + str(td) + ', replaced with realization: ' + str(replacement_counter))
        # update replacement counter
        replacement_counter += 1
        continue
        
    # =============================================================================
    # SAVE DATA 
    # =============================================================================
    # save normalized arrival time difference data
    save_filename_btdn = workdir + '\\' + 'arrival_norm_diff_' + model_dirname + '_'  + str(nlay) + '_' + str(nrow) + '_' + str(ncol) +'.csv'
    save_data = np.append(at_diff_norm.flatten('C'), [km2_mean])
    np.savetxt(save_filename_btdn, save_data, delimiter=',', fmt='%.3e')
    
    # save unnormalized breakthrough data
    save_filename_btd = workdir + '\\' + 'arrival_norm_' + model_dirname + '_' + str(nlay) + '_' + str(nrow) + '_' + str(ncol) +'.csv'
    save_data = np.append(at_array_norm.flatten('C'), [km2_mean])
    np.savetxt(save_filename_btd, save_data, delimiter=',', fmt='%.3e')
    
    # Try to delete the previous folder of MODFLOW and MT3D files
    if td > 1:
        old_model_ws = os.path.join(workdir, ('td'+ str(td-1)))
        # Try to remove tree; if failed show an error using try...except on screen
        try:
            shutil.rmtree(old_model_ws)
        except OSError as e:
            print ("Error: %s - %s." % (e.filename, e.strerror))
    
    # Update td counter        
    td += 1
    
# Print final run time
end_td = time.time() # end timer
print('Minutes to run ' + str(ntraining_data) + ' training simulations: ', (end_td - start_td)/60) # show run time
    
# =============================================================================
# PLOT DATA 
# =============================================================================
# Define grid    
y, x = np.mgrid[slice(0, Ly + grid_size[1], grid_size[1]),
                  slice(0, Lx + grid_size[2], grid_size[2])]
# layer to plot
ilayer = 10
# # fontsize
fs = 24

hfont = {'fontname':'Arial'}


n = 21
colors = np.flipud(plt.cm.viridis(np.linspace(0,1,n)))
r, c, s = np.shape(at_array_norm)
x_coord = np.linspace(0, grid_size[2]*s, s)

print(np.std(at_array_norm[:,:,0]))

fig0, (ax01, ax02) =  plt.subplots(1, 2, figsize=(14, 4), dpi=400)
for i in range(0,19):
    ax01.plot(x_coord, at_array_norm[i,11,:], '.-', color=colors[i])
    ax02.plot(x_coord, at_array_norm[11,i,:], '.-', color=colors[i]) 
# Load breakthrough time data
tdata_norm = np.loadtxt(save_filename_btdn, delimiter=',')
load_km2 = tdata_norm[-1]
tdata_norm = tdata_norm[0:-1]
tdata_norm = tdata_norm.reshape(nlay, nrow, ncol)
    
plot_km2 = field_km2[ilayer,:,:]/9.869233E-13*1000
plot_2d(plot_km2, grid_size[1], grid_size[2], 'Permeability', cmap='Greys')
# clim_pv = np.max(np.abs([np.max(plot_km2), np.min(plot_km2)]))
# plt.clim(-clim_pv, clim_pv)

# First figure with concentration data
fig1 = plt.figure(figsize=(10, 15))
ax0 = fig1.add_subplot(3, 1, 1, aspect='equal')
imp = plt.pcolor(x, y, conc[18,ilayer,:,:], cmap='OrRd', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
plt.clim(0,0.4) 
cbar.set_label('Solute concentration', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax0.tick_params(axis='both', which='major', labelsize=fs)
plt.title('Time: %1.1f min' %timearray[18], fontsize=fs+2, **hfont)

ax1 = fig1.add_subplot(3, 1, 2, aspect='equal')
imp = plt.pcolor(x, y, conc[20,ilayer,:,:], cmap='OrRd', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
plt.clim(0,0.4) 
cbar.set_label('Solute concentration', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax1.tick_params(axis='both', which='major', labelsize=fs)
plt.title('Time: %1.1f min' %timearray[20], fontsize=fs+2, **hfont)

ax2 = fig1.add_subplot(3, 1, 3, aspect='equal')
imp = plt.pcolor(x, y, conc[-1,ilayer,:,:], cmap='OrRd', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
plt.clim(0,0.4) 
cbar.set_label('Solute concentration', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax2.tick_params(axis='both', which='major', labelsize=fs)
plt.title('Time: %1.1f min' %timearray[-1], fontsize=fs+2, **hfont)
plt.ylabel('Distance [cm]', fontsize=fs, **hfont)

# Second figure with head and breakthrough time difference maps
fig2 = plt.figure(figsize=(10, 15))
ax0 = fig2.add_subplot(3, 1, 1, aspect='equal')
dp_pressures = at_array[ilayer,:,:]
imp = plt.pcolor(x, y, dp_pressures, cmap='Purples', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
plt.clim(0, np.max(dp_pressures)) 
cbar.set_label('Time [min]', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax0.tick_params(axis='both', which='major', labelsize=fs)
plt.title('0.50 Quantile Arrival Time [min]', fontsize=fs+2, **hfont)

ax1 = fig2.add_subplot(3, 1, 2, aspect='equal')
imp = plt.pcolor(x, y, at_array_norm[ilayer,:,:], cmap='Blues', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
# plt.clim(0,1) 
cbar.set_label('PV [-]', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax1.tick_params(axis='both', which='major', labelsize=fs)
plt.title('0.50 Quantile Arrival Time [-]', fontsize=fs+2, **hfont)

ax2 = fig2.add_subplot(3, 1, 3, aspect='equal')
imp = plt.pcolor(x, y, tdata_norm[ilayer,:,:], cmap='PiYG', edgecolors='k', linewidths=0.2)
cbar = plt.colorbar()
cbar.set_label('Pore Volumes', fontsize=fs, **hfont)
cbar.ax.tick_params(labelsize= (fs-2)) 
ax2.set_xlabel('Distance from inlet [cm]', fontsize=fs, **hfont)
ax2.tick_params(axis='both', which='major', labelsize=fs)
plt.ylabel('Distance [cm]', fontsize=fs, **hfont)
plt.title('Quantile Arrival Time Difference', fontsize=fs+2, **hfont)
clim_pv = np.max(np.abs([np.max(tdata_norm), np.min(tdata_norm)]))
plt.clim(-clim_pv, clim_pv)

gaussian_arr = np.random.normal(0,0.006, tdata_norm[:,:,0].shape)
syn_data_inlet = tdata_norm[:,:,0]+gaussian_arr

plot_2d(syn_data_inlet, grid_size[0], grid_size[1], 'arrival time', cmap='bwr')
clim_pv = np.max(np.abs([np.max(syn_data_inlet), np.min(syn_data_inlet)]))
plt.clim(-clim_pv, clim_pv)

plot_2d(tdata_norm[:,:,0], grid_size[0], grid_size[1], 'arrival time', cmap='bwr')
clim_pv = np.max(np.abs([np.max(syn_data_inlet), np.min(syn_data_inlet)]))
plt.clim(-clim_pv, clim_pv)